/**
 * æ•°æ®å¯è§†åŒ–ç»„ä»¶ - çº¯JavaScripté€»è¾‘
 * æ”¯æŒå¤šæµ‹ç‚¹å¯¹æ¯”ã€é™é‡‡æ ·ã€åˆ†é¡µè¡¨æ ¼ç­‰åŠŸèƒ½
 */
class DataVisualization extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this.chart = null;
        this.selectedPoints = new Set();
        this.allData = [];
        this.displayData = [];
        this.currentPage = 1;
        this.pageSize = 20;
        this.totalPages = 0;
        this.dataSource = '';
        this.availablePoints = [];
    }

    async connectedCallback() {
        await this.loadResources();
        setTimeout(() => {
            this.bindEvents();
        }, 100);
    }

    async loadResources() {
        // åŠ è½½CSS
        try {
            const cssLink = document.createElement('link');
            cssLink.rel = 'stylesheet';
            cssLink.href = './components/data-visualization/data-visualization.css';
            this.shadowRoot.appendChild(cssLink);
        } catch (error) {
            console.error('Failed to load CSS:', error);
        }

        // åŠ è½½HTML
        try {
            const response = await fetch('./components/data-visualization/data-visualization.html');
            const html = await response.text();
            this.shadowRoot.innerHTML += html;
        } catch (error) {
            console.error('Failed to load HTML:', error);
            // å¦‚æœåŠ è½½å¤±è´¥ï¼Œä½¿ç”¨å†…åµŒHTMLä½œä¸ºåå¤‡
            this.shadowRoot.innerHTML += this.getFallbackHTML();
        }

        // åŠ è½½EChartsåˆ°å…¨å±€
        try {
            if (!window.echarts) {
                const script = document.createElement('script');
                script.src = './lib/echarts/echarts.min.js';
                document.head.appendChild(script);
                
                // ç­‰å¾…EChartsåŠ è½½å®Œæˆ
                await new Promise((resolve) => {
                    script.onload = resolve;
                });
            }
        } catch (error) {
            console.error('Failed to load ECharts:', error);
        }
    }

    getFallbackHTML() {
        return `
        <div class="visualization-container">
            <div class="visualization-header">
                <h3 class="visualization-title" id="dataSourceName">æ—¶åºæ•°æ®æŸ¥è¯¢</h3>
                <button class="close-btn" id="closeBtn">Ã—</button>
            </div>
            
            <div class="content-area">
                <div class="chart-section">
                    <div class="chart-header">
                        <h4 class="chart-title">è¶‹åŠ¿å›¾</h4>
                    </div>
                    <div class="chart-container" id="chartContainer">
                        <!-- EChartså›¾è¡¨å°†åœ¨è¿™é‡Œæ¸²æŸ“ -->
                    </div>
                </div>
                
                <div class="operations-section">
                    <div class="operations-header">
                        <h4 class="operations-title">æ“ä½œ</h4>
                        <div class="operations-actions">
                            <button class="action-btn" id="dataCleanBtn">æ•°æ®æ¸…ç†</button>
                            <button class="action-btn" id="importBtn">å¯¼å…¥æ•°æ®</button>
                            <button class="action-btn" id="exportBtn">å¯¼å‡ºæ•°æ®</button>
                        </div>
                    </div>
                    <div class="operations-content">
                        <div class="query-controls">
                            <div class="query-row">
                                <div class="query-item">
                                    <label class="query-label">å¼€å§‹æ—¶é—´</label>
                                    <input type="datetime-local" class="query-input" id="startTime">
                                </div>
                                <div class="query-item">
                                    <label class="query-label">ç»“æŸæ—¶é—´</label>
                                    <input type="datetime-local" class="query-input" id="endTime">
                                </div>
                                <div class="query-item">
                                    <label class="query-label">èšåˆå‡½æ•°</label>
                                    <select class="query-select" id="aggregationFunction">
                                        <option value="raw">åŸå§‹æ•°æ®</option>
                                        <option value="avg">å¹³å‡å€¼</option>
                                        <option value="max">æœ€å¤§å€¼</option>
                                        <option value="min">æœ€å°å€¼</option>
                                        <option value="sum">æ±‚å’Œ</option>
                                        <option value="count">è®¡æ•°</option>
                                    </select>
                                </div>
                            </div>
                            
                            <div class="query-row">
                                <div class="query-item">
                                    <label class="query-label">å¿«é€Ÿé€‰æ‹©</label>
                                    <div class="quick-time-buttons">
                                        <button class="quick-time-btn" data-range="1h">æœ€è¿‘1å°æ—¶</button>
                                        <button class="quick-time-btn" data-range="6h">æœ€è¿‘6å°æ—¶</button>
                                        <button class="quick-time-btn" data-range="24h">æœ€è¿‘24å°æ—¶</button>
                                        <button class="quick-time-btn" data-range="7d">æœ€è¿‘7å¤©</button>
                                    </div>
                                </div>
                                <div class="query-actions">
                                    <button class="query-btn" id="queryBtn">æŸ¥è¯¢æ•°æ®</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="table-section">
                    <div class="table-header">
                        <span class="table-title">æ•°æ®åˆ—è¡¨</span>
                        <div class="selected-points-in-header">
                            <span class="selected-points-label">å·²é€‰æµ‹ç‚¹:</span>
                            <div class="selected-points-compact" id="selectedPointsList">
                                <!-- åŠ¨æ€ç”Ÿæˆå·²é€‰æµ‹ç‚¹åˆ—è¡¨ -->
                            </div>
                        </div>
                    </div>
                    <div class="table-wrapper">
                        <table id="dataTable">
                            <thead>
                                <tr>
                                    <th>æ—¶é—´</th>
                                    <!-- åŠ¨æ€ç”Ÿæˆæµ‹ç‚¹åˆ—å¤´ -->
                                </tr>
                            </thead>
                            <tbody id="tableBody">
                                <!-- åŠ¨æ€ç”Ÿæˆè¡¨æ ¼æ•°æ® -->
                            </tbody>
                        </table>
                        <div class="pagination">
                            <div class="pagination-left">
                                <div class="page-size-selector">
                                    <span>æ¯é¡µæ˜¾ç¤º</span>
                                    <select class="page-size-select" id="pageSizeSelect">
                                        <option value="10">10æ¡</option>
                                        <option value="20" selected>20æ¡</option>
                                        <option value="50">50æ¡</option>
                                        <option value="100">100æ¡</option>
                                    </select>
                                </div>
                                <span class="page-info" id="pageInfo">ç¬¬ 1 é¡µ / å…± 1 é¡µ</span>
                            </div>
                            <div class="pagination-right">
                                <button id="prevBtn">ä¸Šä¸€é¡µ</button>
                                <button id="nextBtn">ä¸‹ä¸€é¡µ</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>`;
    }

    show(dataSource, points = []) {
        console.log('æ˜¾ç¤ºæ•°æ®å¯è§†åŒ–:', dataSource, points);
        this.setAttribute('show', '');
        this.dataSource = dataSource;
        this.availablePoints = points;
        // å¦‚æœæ˜¯æ–°çš„æ˜¾ç¤ºï¼Œä½¿ç”¨ä¼ å…¥çš„æµ‹ç‚¹ï¼›å¦‚æœæ˜¯å·²å­˜åœ¨çš„ç»„ä»¶ï¼Œä¿æŒå½“å‰é€‰ä¸­çš„æµ‹ç‚¹
        if (!this.selectedPoints || this.selectedPoints.size === 0) {
            this.selectedPoints = new Set(points);
        }
        this.allData = [];
        this.displayData = [];
        this.currentPage = 1;
        this.pageSize = 20; // ä¸HTMLé»˜è®¤å€¼ä¿æŒä¸€è‡´
        
        // è®¾ç½®æ•°æ®æºåç§°
        const dataSourceNameEl = this.shadowRoot.getElementById('dataSourceName');
        if (dataSourceNameEl) {
            dataSourceNameEl.textContent = 'æ—¶åºæ•°æ®æŸ¥è¯¢';
        }
        
        console.log('ç»„ä»¶å·²æ˜¾ç¤ºï¼Œå¼€å§‹åˆå§‹åŒ–...');
        
        // å¼ºåˆ¶é‡æ–°è®¡ç®—å¸ƒå±€
        setTimeout(() => {
            // æ›´æ–°å·²é€‰æµ‹ç‚¹åˆ—è¡¨
            this.updateSelectedPointsList();
            
            // ç»‘å®šæŸ¥è¯¢æ§ä»¶äº‹ä»¶
            this.bindQueryEvents();
            
            // åŠ è½½æ•°æ®
            this.loadData();
            
            // å¼ºåˆ¶è§¦å‘é‡æ–°å¸ƒå±€
            this.updateLayout();
        }, 50);
    }

    hide() {
        console.log('éšè—æ•°æ®å¯è§†åŒ–');
        this.removeAttribute('show');
        if (this.chart) {
            this.chart.dispose();
            this.chart = null;
        }
    }

    updateLayout() {
        // å¼ºåˆ¶é‡æ–°è®¡ç®—å°ºå¯¸
        const chartContainer = this.shadowRoot.getElementById('chartContainer');
        if (chartContainer) {
            chartContainer.style.display = 'none';
            chartContainer.offsetHeight; // è§¦å‘é‡æ’
            chartContainer.style.display = '';
            
            // å¦‚æœå›¾è¡¨å·²å­˜åœ¨ï¼Œå¼ºåˆ¶é‡æ–°è°ƒæ•´å¤§å°
            if (this.chart) {
                setTimeout(() => {
                    this.chart.resize();
                }, 100);
            }
        }
    }

    bindEvents() {
        // å…³é—­æŒ‰é’®
        const closeBtn = this.shadowRoot.getElementById('closeBtn');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                this.hide();
            });
        }

        // æ•°æ®æ¸…ç†æŒ‰é’®
        const dataCleanBtn = this.shadowRoot.getElementById('dataCleanBtn');
        if (dataCleanBtn) {
            dataCleanBtn.addEventListener('click', () => {
                this.showDataCleanModal();
            });
        }

        // å¯¼å…¥æ•°æ®æŒ‰é’®
        const importBtn = this.shadowRoot.getElementById('importBtn');
        if (importBtn) {
            importBtn.addEventListener('click', () => {
                this.showImportModal();
            });
        }

        // å¯¼å‡ºæ•°æ®æŒ‰é’®
        const exportBtn = this.shadowRoot.getElementById('exportBtn');
        if (exportBtn) {
            exportBtn.addEventListener('click', () => {
                this.showExportModal();
            });
        }

        // åˆ†é¡µå¤§å°é€‰æ‹©
        const pageSizeSelect = this.shadowRoot.getElementById('pageSizeSelect');
        if (pageSizeSelect) {
            pageSizeSelect.value = this.pageSize; // ç¡®ä¿é€‰æ‹©å™¨æ˜¾ç¤ºæ­£ç¡®çš„å€¼
            pageSizeSelect.addEventListener('change', (e) => {
                this.pageSize = parseInt(e.target.value);
                this.currentPage = 1;
                this.updateTable();
            });
        }

        // åˆ†é¡µæŒ‰é’®
        const prevBtn = this.shadowRoot.getElementById('prevBtn');
        const nextBtn = this.shadowRoot.getElementById('nextBtn');
        
        if (prevBtn) {
            prevBtn.addEventListener('click', () => {
                if (this.currentPage > 1) {
                    this.currentPage--;
                    this.updateTable();
                }
            });
        }

        if (nextBtn) {
            nextBtn.addEventListener('click', () => {
                if (this.currentPage < this.totalPages) {
                    this.currentPage++;
                    this.updateTable();
                }
            });
        }

        // ESCé”®å…³é—­
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this.hasAttribute('show')) {
                this.hide();
            }
        });
    }

    bindQueryEvents() {
        // ç»‘å®šå¿«é€Ÿæ—¶é—´æŒ‰é’®
        const quickTimeBtns = this.shadowRoot.querySelectorAll('.quick-time-btn');
        quickTimeBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                // ç§»é™¤å…¶ä»–æŒ‰é’®çš„activeçŠ¶æ€
                quickTimeBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                const range = btn.dataset.range;
                const endTime = new Date();
                const startTime = new Date();
                
                switch (range) {
                    case '1h':
                        startTime.setHours(startTime.getHours() - 1);
                        break;
                    case '6h':
                        startTime.setHours(startTime.getHours() - 6);
                        break;
                    case '24h':
                        startTime.setDate(startTime.getDate() - 1);
                        break;
                    case '7d':
                        startTime.setDate(startTime.getDate() - 7);
                        break;
                }
                
                const startTimeInput = this.shadowRoot.getElementById('startTime');
                const endTimeInput = this.shadowRoot.getElementById('endTime');
                
                if (startTimeInput) {
                    startTimeInput.value = startTime.toISOString().slice(0, 16);
                }
                if (endTimeInput) {
                    endTimeInput.value = endTime.toISOString().slice(0, 16);
                }
            });
        });

        // ç»‘å®šæŸ¥è¯¢æŒ‰é’®
        const queryBtn = this.shadowRoot.getElementById('queryBtn');
        if (queryBtn) {
            queryBtn.addEventListener('click', () => {
                this.loadData();
            });
        }
    }

    updateSelectedPointsList() {
        const selectedPointsList = this.shadowRoot.getElementById('selectedPointsList');
        if (!selectedPointsList) return;

        selectedPointsList.innerHTML = '';
        
        if (this.selectedPoints.size === 0) {
            selectedPointsList.innerHTML = '<span style="color: #999; font-size: 12px;">æš‚æ— é€‰ä¸­çš„æµ‹ç‚¹</span>';
            return;
        }

        this.selectedPoints.forEach(point => {
            const pointItem = document.createElement('div');
            pointItem.className = 'selected-point-item';
            pointItem.innerHTML = `
                <span class="selected-point-name">${point}</span>
                <button class="remove-point" data-point="${point}">Ã—</button>
            `;
            
            // ç»‘å®šç§»é™¤äº‹ä»¶
            const removeBtn = pointItem.querySelector('.remove-point');
            removeBtn.addEventListener('click', () => {
                this.removeSelectedPoint(point);
            });
            
            selectedPointsList.appendChild(pointItem);
        });
    }

    removeSelectedPoint(point) {
        console.log('ç§»é™¤æµ‹ç‚¹:', point);
        this.selectedPoints.delete(point);
        
        // æ›´æ–°å…¨å±€é€‰ä¸­çš„æµ‹ç‚¹
        if (window.selectedDataPoints) {
            window.selectedDataPoints.delete(point);
        }
        
        // æ›´æ–°æ˜¾ç¤º
        this.updateSelectedPointsList();
        
        // å¦‚æœæ²¡æœ‰é€‰ä¸­çš„æµ‹ç‚¹äº†ï¼Œæ˜¾ç¤ºç©ºçŠ¶æ€
        if (this.selectedPoints.size === 0) {
            console.log('æ²¡æœ‰é€‰ä¸­çš„æµ‹ç‚¹äº†ï¼Œæ˜¾ç¤ºç©ºçŠ¶æ€');
            this.showEmptyState();
        } else {
            // é‡æ–°åŠ è½½æ•°æ®
            this.loadData();
        }
    }

    async loadData() {
        try {
            console.log('å¼€å§‹åŠ è½½æ•°æ®ï¼Œé€‰ä¸­çš„æµ‹ç‚¹:', Array.from(this.selectedPoints));
            console.log('selectedPoints size:', this.selectedPoints.size);
            
            if (this.selectedPoints.size === 0) {
                console.log('æ²¡æœ‰é€‰ä¸­çš„æµ‹ç‚¹ï¼Œæ˜¾ç¤ºç©ºçŠ¶æ€');
                this.showEmptyState();
                return;
            }
            
            // æ¨¡æ‹Ÿæ•°æ®åŠ è½½ - å®é™…é¡¹ç›®ä¸­åº”è¯¥è°ƒç”¨API
            console.log('å¼€å§‹ç”Ÿæˆæ¨¡æ‹Ÿæ•°æ®...');
            const mockData = this.generateMockData();
            console.log('ç”Ÿæˆçš„æ¨¡æ‹Ÿæ•°æ®:', mockData.length, 'æ¡è®°å½•');
            if (mockData.length > 0) {
                console.log('ç¬¬ä¸€æ¡æ•°æ®:', mockData[0]);
            }
            
            this.allData = mockData;
            
            // åº”ç”¨é™é‡‡æ ·
            console.log('åº”ç”¨é™é‡‡æ ·...');
            this.applyDownsampling();
            console.log('é™é‡‡æ ·åæ•°æ®:', this.displayData.length, 'æ¡è®°å½•');
            
            // åˆå§‹åŒ–å›¾è¡¨ï¼ˆå¦‚æœè¿˜æ²¡æœ‰åˆå§‹åŒ–ï¼‰
            if (!this.chart) {
                console.log('åˆå§‹åŒ–å›¾è¡¨...');
                this.initChart();
            } else {
                console.log('æ›´æ–°å¯è§†åŒ–...');
                // æ›´æ–°å¯è§†åŒ–
                this.updateVisualization();
            }
            
        } catch (error) {
            console.error('åŠ è½½æ•°æ®å¤±è´¥:', error);
            this.showError('åŠ è½½æ•°æ®å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
        }
    }

    showEmptyState() {
        // æ¸…ç†EChartså®ä¾‹
        if (this.chart) {
            this.chart.dispose();
            this.chart = null;
        }
        
        const chartContainer = this.shadowRoot.getElementById('chartContainer');
        if (chartContainer) {
            chartContainer.innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: #999;">
                    <div style="font-size: 48px; margin-bottom: 16px;">ğŸ“Š</div>
                    <div style="font-size: 14px; margin-bottom: 8px;">æš‚æ— æ•°æ®</div>
                    <div style="font-size: 12px;">è¯·åœ¨å·¦ä¾§é€‰æ‹©æµ‹ç‚¹åç‚¹å‡»æŸ¥è¯¢</div>
                </div>
            `;
        }
        
        // ç¡®ä¿è¡¨æ ¼åŒºåŸŸæ˜¾ç¤ºå¹¶æ›´æ–°ä¸ºç©ºçŠ¶æ€
        this.updateTable();
    }

    showError(message) {
        const chartContainer = this.shadowRoot.getElementById('chartContainer');
        if (chartContainer) {
            chartContainer.innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: #ff4d4f;">
                    <div style="font-size: 48px; margin-bottom: 16px;">âŒ</div>
                    <div style="font-size: 14px;">${message}</div>
                </div>
            `;
        }
    }

    generateMockData() {
        const data = [];
        const now = Date.now();
        const selectedPointsArray = Array.from(this.selectedPoints);
        
        console.log('ç”Ÿæˆæ¨¡æ‹Ÿæ•°æ®ï¼Œæµ‹ç‚¹æ•°é‡:', selectedPointsArray.length, 'æµ‹ç‚¹åˆ—è¡¨:', selectedPointsArray);
        
        if (selectedPointsArray.length === 0) {
            console.log('æ²¡æœ‰é€‰ä¸­çš„æµ‹ç‚¹ï¼Œè¿”å›ç©ºæ•°æ®');
            return [];
        }
        
        // ç”Ÿæˆ1000ä¸ªæ•°æ®ç‚¹
        for (let i = 0; i < 1000; i++) {
            const record = {
                timestamp: now - (1000 - i) * 1000, // æ¯ç§’ä¸€ä¸ªæ•°æ®ç‚¹
                values: {}
            };
            
            // ä¸ºæ¯ä¸ªé€‰ä¸­çš„æµ‹ç‚¹ç”Ÿæˆæ•°æ®
            selectedPointsArray.forEach((pointName, index) => {
                // ä¸ºä¸åŒæµ‹ç‚¹ç”Ÿæˆä¸åŒç‰¹å¾çš„æ•°æ®
                const baseValue = 100 + index * 50;
                record.values[pointName] = baseValue + Math.sin(i * 0.01 + index) * 30 + Math.random() * 20;
            });
            
            data.push(record);
        }
        
        console.log('ç”Ÿæˆäº†', data.length, 'æ¡æ•°æ®');
        console.log('ç¬¬ä¸€æ¡æ•°æ®:', data[0]);
        return data;
    }

    applyDownsampling() {
        if (this.allData.length <= 2000) {
            this.displayData = this.allData;
            this.hideDownsamplingInfo();
            return;
        }

        // ä½¿ç”¨LTTBç®—æ³•è¿›è¡Œé™é‡‡æ ·
        const threshold = 1000; // ç›®æ ‡æ•°æ®ç‚¹æ•°
        this.displayData = this.lttbDownsample(this.allData, threshold);
        this.showDownsamplingInfo(this.allData.length, this.displayData.length);
    }

    lttbDownsample(data, threshold) {
        if (data.length <= threshold) {
            return data;
        }

        const sampled = [];
        const bucketSize = Math.floor(data.length / threshold);
        
        // ç®€åŒ–çš„é™é‡‡æ ·ï¼šå‡åŒ€é‡‡æ ·
        for (let i = 0; i < data.length; i += bucketSize) {
            sampled.push(data[i]);
        }
        
        // ç¡®ä¿åŒ…å«æœ€åä¸€ä¸ªç‚¹
        if (sampled[sampled.length - 1] !== data[data.length - 1]) {
            sampled.push(data[data.length - 1]);
        }
        
        return sampled;
    }

    showDownsamplingInfo(originalCount, sampledCount) {
        console.log(`æ•°æ®é™é‡‡æ ·: ${originalCount} -> ${sampledCount}`);
    }

    hideDownsamplingInfo() {
        console.log('æ— éœ€é™é‡‡æ ·');
    }

    initChart() {
        const chartContainer = this.shadowRoot.getElementById('chartContainer');
        if (chartContainer && window.echarts) {
            // å¦‚æœå®¹å™¨æ˜¾ç¤ºçš„æ˜¯ç©ºçŠ¶æ€ï¼Œæ¸…ç©ºå®ƒ
            if (chartContainer.querySelector('div[style*="ğŸ“Š"]')) {
                chartContainer.innerHTML = '';
            }
            
            // æ¸…é™¤åŠ è½½æç¤º
            const loadingEl = chartContainer.querySelector('.loading');
            if (loadingEl) {
                loadingEl.remove();
            }
            
            // ç­‰å¾…DOMå®Œå…¨æ¸²æŸ“ï¼Œä½¿ç”¨æ›´é•¿çš„å»¶è¿Ÿå’Œå¤šæ¬¡æ£€æŸ¥
            const tryInitChart = (attempt = 0) => {
                if (window.echarts && !this.chart) {
                    const rect = chartContainer.getBoundingClientRect();
                    console.log(`å°è¯•åˆå§‹åŒ–å›¾è¡¨ (ç¬¬${attempt + 1}æ¬¡):`, rect);
                    
                    // å¦‚æœé«˜åº¦å¤ªå°ï¼Œç»§ç»­ç­‰å¾…
                    if (rect.height < 100 && attempt < 5) {
                        setTimeout(() => tryInitChart(attempt + 1), 200);
                        return;
                    }
                    
                    // å¼ºåˆ¶è®¾ç½®æœ€å°é«˜åº¦
                    if (rect.height < 350) {
                        chartContainer.style.minHeight = '350px';
                    }
                    
                    try {
                        this.chart = window.echarts.init(chartContainer);
                        console.log('å›¾è¡¨åˆå§‹åŒ–æˆåŠŸ');
                        this.updateChart();
                        console.log('å›¾è¡¨åˆå§‹åŒ–æˆåŠŸ');
                    } catch (error) {
                        console.error('å›¾è¡¨åˆå§‹åŒ–å¤±è´¥:', error);
                        setTimeout(() => tryInitChart(attempt + 1), 500);
                    }
                } else if (attempt < 10) {
                    setTimeout(() => tryInitChart(attempt + 1), 200);
                } else {
                    console.error('ECharts not loaded or chart container not found');
                }
            };
            
            // å¼€å§‹å°è¯•åˆå§‹åŒ–
            setTimeout(() => tryInitChart(), 100);
        }
    }

    updateVisualization() {
        this.updateChart();
        this.updateTable();
    }

    updateChart() {
        if (!this.chart || !this.displayData.length || this.selectedPoints.size === 0) return;

        const series = [];
        const selectedPointsArray = Array.from(this.selectedPoints);
        
        selectedPointsArray.forEach((point, index) => {
            const data = this.displayData.map(record => [
                record.timestamp,
                record.values[point] || 0
            ]);
            
            series.push({
                name: point,
                type: 'line',
                data: data,
                smooth: true,
                symbol: 'none',
                lineStyle: {
                    width: 2
                },
                itemStyle: {
                    color: this.getColorForPoint(point)
                }
            });
        });

        const option = {
            title: {
                text: 'æ•°æ®è¶‹åŠ¿',
                left: 'center',
                top: 10,
                textStyle: {
                    fontSize: 14,
                    fontWeight: 'bold'
                }
            },
            tooltip: {
                trigger: 'axis',
                formatter: function(params) {
                    if (!params || params.length === 0) return '';
                    
                    const time = new Date(params[0].value[0]).toLocaleString();
                    let result = `æ—¶é—´: ${time}<br/>`;
                    params.forEach(param => {
                        result += `${param.seriesName}: ${param.value[1].toFixed(2)}<br/>`;
                    });
                    return result;
                }
            },
            legend: {
                data: selectedPointsArray,
                top: 40,
                left: 'center',
                textStyle: {
                    fontSize: 12
                }
            },
            grid: {
                left: '8%',
                right: '8%',
                bottom: '20%',
                top: '20%'
            },
            xAxis: {
                type: 'time',
                axisLabel: {
                    formatter: function(value) {
                        return new Date(value).toLocaleString();
                    }
                }
            },
            yAxis: {
                type: 'value',
                axisLabel: {
                    formatter: function(value) {
                        return value.toFixed(2);
                    }
                }
            },
            dataZoom: [
                {
                    type: 'inside',
                    start: 0,
                    end: 100
                },
                {
                    start: 0,
                    end: 100,
                    handleStyle: {
                        backgroundColor: '#3370ff'
                    }
                }
            ],
            toolbox: {
                right: 20,
                feature: {
                    restore: {},
                    saveAsImage: {}
                }
            },
            series: series
        };

        this.chart.setOption(option, true); // ç¬¬äºŒä¸ªå‚æ•°trueè¡¨ç¤ºä¸åˆå¹¶ï¼Œå®Œå…¨æ›¿æ¢
    }

    updateTable() {
        console.log('æ›´æ–°è¡¨æ ¼ï¼ŒdisplayData length:', this.displayData.length);
        console.log('selectedPoints:', Array.from(this.selectedPoints));
        
        const tableSection = this.shadowRoot.querySelector('.table-section');
        const table = this.shadowRoot.getElementById('dataTable');
        const tbody = this.shadowRoot.getElementById('tableBody');
        
        // ç¡®ä¿è¡¨æ ¼åŒºåŸŸå§‹ç»ˆæ˜¾ç¤º
        if (tableSection) {
            tableSection.style.display = 'flex';
        }
        
        // æ›´æ–°è¡¨æ ¼å¤´éƒ¨
        if (!table) {
            console.error('æ‰¾ä¸åˆ°è¡¨æ ¼å…ƒç´ ');
            return;
        }
        
        const headerRow = table.querySelector('thead tr');
        if (!headerRow) {
            console.error('æ‰¾ä¸åˆ°è¡¨æ ¼å¤´éƒ¨');
            return;
        }
        
        headerRow.innerHTML = '<th>æ—¶é—´</th>';
        
        const selectedPointsArray = Array.from(this.selectedPoints);
        selectedPointsArray.forEach(point => {
            const th = document.createElement('th');
            th.textContent = point;
            headerRow.appendChild(th);
        });
        
        console.log('è¡¨æ ¼å¤´éƒ¨æ›´æ–°å®Œæˆï¼Œåˆ—æ•°:', headerRow.children.length);

        // æ›´æ–°è¡¨æ ¼æ•°æ®
        if (!tbody) {
            console.error('æ‰¾ä¸åˆ°è¡¨æ ¼ä½“');
            return;
        }
        
        tbody.innerHTML = '';
        
        if (!this.displayData.length || this.selectedPoints.size === 0) {
            console.log('æ²¡æœ‰æ˜¾ç¤ºæ•°æ®æˆ–æ²¡æœ‰é€‰ä¸­çš„æµ‹ç‚¹ï¼Œæ˜¾ç¤ºç©ºçŠ¶æ€æç¤º');
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = Math.max(1, selectedPointsArray.length + 1);
            td.style.textAlign = 'center';
            td.style.color = '#999';
            td.style.padding = '60px 20px';
            td.style.fontSize = '14px';
            td.textContent = this.selectedPoints.size === 0 ? 'è¯·é€‰æ‹©æµ‹ç‚¹' : 'æš‚æ— æ•°æ®';
            tr.appendChild(td);
            tbody.appendChild(tr);
            
            // æ›´æ–°åˆ†é¡µä¿¡æ¯ä¸ºç©ºçŠ¶æ€
            this.totalPages = 0;
            this.currentPage = 1; // é‡ç½®å½“å‰é¡µ
            this.updatePagination();
            return;
        }

        // è®¡ç®—åˆ†é¡µ
        this.totalPages = Math.ceil(this.displayData.length / this.pageSize);
        this.currentPage = Math.min(this.currentPage, this.totalPages);
        
        console.log('åˆ†é¡µä¿¡æ¯ï¼šå½“å‰é¡µ', this.currentPage, 'æ€»é¡µæ•°', this.totalPages);
        
        const startIndex = (this.currentPage - 1) * this.pageSize;
        const endIndex = Math.min(startIndex + this.pageSize, this.displayData.length);
        const pageData = this.displayData.slice(startIndex, endIndex);
        
        console.log('å½“å‰é¡µæ•°æ®èŒƒå›´:', startIndex, '-', endIndex, 'å®é™…æ•°æ®é‡:', pageData.length);
        
        pageData.forEach((record, index) => {
            const tr = document.createElement('tr');
            
            // æ—¶é—´åˆ—
            const timeTd = document.createElement('td');
            timeTd.textContent = new Date(record.timestamp).toLocaleString();
            tr.appendChild(timeTd);
            
            // æµ‹ç‚¹æ•°æ®åˆ—
            selectedPointsArray.forEach(point => {
                const td = document.createElement('td');
                const value = record.values[point] || 0;
                td.textContent = value.toFixed(2);
                tr.appendChild(td);
            });
            
            tbody.appendChild(tr);
        });
        
        console.log('è¡¨æ ¼æ•°æ®æ›´æ–°å®Œæˆï¼Œè¡Œæ•°:', tbody.children.length);

        // æ›´æ–°åˆ†é¡µä¿¡æ¯
        this.updatePagination();
    }

    updatePagination() {
        const pageInfo = this.shadowRoot.getElementById('pageInfo');
        const prevBtn = this.shadowRoot.getElementById('prevBtn');
        const nextBtn = this.shadowRoot.getElementById('nextBtn');
        
        if (pageInfo) {
            if (this.totalPages === 0) {
                pageInfo.textContent = 'æš‚æ— æ•°æ®';
            } else {
                pageInfo.textContent = `ç¬¬ ${this.currentPage} é¡µ / å…± ${this.totalPages} é¡µ`;
            }
        }
        
        if (prevBtn) {
            prevBtn.disabled = this.totalPages === 0 || this.currentPage <= 1;
        }
        
        if (nextBtn) {
            nextBtn.disabled = this.totalPages === 0 || this.currentPage >= this.totalPages;
        }
    }

    getColorForPoint(pointName) {
        // ä¸ºæ¯ä¸ªæµ‹ç‚¹åç§°ç”Ÿæˆå›ºå®šçš„é¢œè‰²
        const colors = [
            '#3370ff', '#00b42a', '#ff7d00', '#f53f3f', '#722ed1',
            '#13c2c2', '#eb2f96', '#faad14', '#a0d911', '#f5222d'
        ];
        
        // ä½¿ç”¨æµ‹ç‚¹åç§°çš„å“ˆå¸Œå€¼æ¥ç¡®ä¿é¢œè‰²ä¸€è‡´æ€§
        let hash = 0;
        for (let i = 0; i < pointName.length; i++) {
            hash = pointName.charCodeAt(i) + ((hash << 5) - hash);
        }
        
        return colors[Math.abs(hash) % colors.length];
    }

    getColorForIndex(index) {
        const colors = [
            '#3370ff', '#00b42a', '#ff7d00', '#f53f3f', '#722ed1',
            '#13c2c2', '#eb2f96', '#faad14', '#a0d911', '#f5222d'
        ];
        return colors[index % colors.length];
    }

    // æ¨¡æ€æ¡†ç›¸å…³æ–¹æ³•
    showDataCleanModal() {
        this.showModal('æ•°æ®æ¸…ç†', `
            <div class="form-group">
                <label>æ¸…ç†è§„åˆ™ï¼š</label>
                <select id="cleanRule">
                    <option value="remove-duplicates">ç§»é™¤é‡å¤æ•°æ®</option>
                    <option value="remove-outliers">ç§»é™¤å¼‚å¸¸å€¼</option>
                    <option value="fill-missing">å¡«å……ç¼ºå¤±å€¼</option>
                </select>
            </div>
            <div class="form-group">
                <label>é˜ˆå€¼è®¾ç½®ï¼š</label>
                <input type="number" id="threshold" placeholder="è¾“å…¥é˜ˆå€¼" />
            </div>
        `, () => {
            const rule = this.shadowRoot.getElementById('cleanRule').value;
            const threshold = this.shadowRoot.getElementById('threshold').value;
            console.log('æ‰§è¡Œæ•°æ®æ¸…ç†:', rule, threshold);
            // è¿™é‡Œå®ç°å®é™…çš„æ•°æ®æ¸…ç†é€»è¾‘
        });
    }

    showImportModal() {
        this.showModal('å¯¼å…¥æ•°æ®', `
            <div class="form-group">
                <label>æ•°æ®æºï¼š</label>
                <select id="importSource">
                    <option value="csv">CSVæ–‡ä»¶</option>
                    <option value="json">JSONæ–‡ä»¶</option>
                    <option value="excel">Excelæ–‡ä»¶</option>
                </select>
            </div>
            <div class="form-group">
                <label>é€‰æ‹©æ–‡ä»¶ï¼š</label>
                <input type="file" id="importFile" accept=".csv,.json,.xlsx,.xls" />
            </div>
        `, () => {
            const source = this.shadowRoot.getElementById('importSource').value;
            const file = this.shadowRoot.getElementById('importFile').files[0];
            console.log('å¯¼å…¥æ•°æ®:', source, file);
            // è¿™é‡Œå®ç°å®é™…çš„æ•°æ®å¯¼å…¥é€»è¾‘
        });
    }

    showExportModal() {
        this.showModal('å¯¼å‡ºæ•°æ®', `
            <div class="form-group">
                <label>å¯¼å‡ºæ ¼å¼ï¼š</label>
                <select id="exportFormat">
                    <option value="csv">CSVæ ¼å¼</option>
                    <option value="json">JSONæ ¼å¼</option>
                    <option value="excel">Excelæ ¼å¼</option>
                </select>
            </div>
            <div class="form-group">
                <label>æ•°æ®èŒƒå›´ï¼š</label>
                <select id="exportRange">
                    <option value="current-page">å½“å‰é¡µ</option>
                    <option value="all">å…¨éƒ¨æ•°æ®</option>
                    <option value="selected">é€‰ä¸­æ•°æ®</option>
                </select>
            </div>
        `, () => {
            const format = this.shadowRoot.getElementById('exportFormat').value;
            const range = this.shadowRoot.getElementById('exportRange').value;
            console.log('å¯¼å‡ºæ•°æ®:', format, range);
            // è¿™é‡Œå®ç°å®é™…çš„æ•°æ®å¯¼å‡ºé€»è¾‘
        });
    }

    showModal(title, content, onConfirm) {
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'modal-overlay';
        modalOverlay.innerHTML = `
            <div class="modal">
                <div class="modal-header">
                    <h3 class="modal-title">${title}</h3>
                    <button class="modal-close">Ã—</button>
                </div>
                <div class="modal-body">
                    ${content}
                </div>
                <div class="modal-footer">
                    <button class="modal-btn">å–æ¶ˆ</button>
                    <button class="modal-btn primary">ç¡®å®š</button>
                </div>
            </div>
        `;

        this.shadowRoot.appendChild(modalOverlay);

        const closeModal = () => {
            this.shadowRoot.removeChild(modalOverlay);
        };

        // ç»‘å®šäº‹ä»¶
        modalOverlay.querySelector('.modal-close').addEventListener('click', closeModal);
        modalOverlay.querySelector('.modal-btn:not(.primary)').addEventListener('click', closeModal);
        modalOverlay.querySelector('.modal-btn.primary').addEventListener('click', () => {
            if (onConfirm) onConfirm();
            closeModal();
        });

        // ç‚¹å‡»é®ç½©å…³é—­
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                closeModal();
            }
        });
    }
}

// æ³¨å†Œè‡ªå®šä¹‰å…ƒç´ 
customElements.define('data-visualization', DataVisualization);
